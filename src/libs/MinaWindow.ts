export interface MinaWindow {
    mina?: {
        /**
         * Used for the mina account of the website requesting to connect to the user, if authorized, it will directly return to the current authorized account.
         * @example
         * ```tsx
         * let accounts
         * // data.result is an array that contains approve account's address
         * try {
         *      accounts = await window.mina.requestAccounts()
         *  } catch (error) {
         *      // if user reject, requestAccounts will throw an error with code and message filed
         *      console.log(error.message, error.code)
         *  }
         * ```
         */
        requestAccounts(): Promise<string[]>;

        /**
         * Request which type of network is using.
         * @example
         * ```tsx
         * const network = await window.mina.requestNetwork();
         * console.log(network); //  'Mainnet' , 'Devnet' , 'Berkeley' or 'Unknown'
         * ```
         */
        requestNetwork(): Promise<'Mainnet' | 'Devnet' | 'Berkeley' | 'Unknown'>;

        /**
         * Used for website request connected account.
         * @example
         * // accounts is an array that contains approve account's address,if no account, will back []
         * const accounts = await window.mina.getAccounts()
         */
        getAccounts(): Promise<string[]>;

        /**
         * This function can sign messages, sign and broadcast payments, stake delegations, and parties. If the payload is unrecognized, an Error is thrown.
         * @example
         * // send zkApp transaction
         * // partiesJson is generated by snarkyjs, you can check the link below for more info
         * // https://docs.minaprotocol.com/en/zkapps/how-zkapps-work
         * try {
         *   const partiesJson = '...'
         *   const { hash } = await window.mina.sendTransaction({
         *     transaction: partiesJson,
         *     feePayer: {
         *       fee: 0.1,
         *       memo: "zk"
         *     }
         *   })
         *   console.log(hash)
         * } catch (error) {
         *   console.log(error.message, error.code)
         * }
         */
        sendTransaction(args: SendTransactionArgs): Promise<{ hash: string }>;

        /**
         * Used for signature.
         * @example
         * try {
         *   let signResult = await window.mina.signMessage({
         *     message: "messages...",
         *   })
         *   console.log(signResult)
         * } catch(error) {
         *   console.log(error.message, error.code)
         * }
         */
        signMessage(args: SignMessageArgs): Promise<SignedData>;

        /**
         * Used for verify signature information.
         * @example
         * let messageVerifyResult: boolean = await window.mina.verifyMessage({
         *   publicKey: "B62qpjxUpgdjzwQfd8q2gzxi99wN7SCgmofpvw27MBkfNHfHoY2VH32",
         *   payload: "messages...",
         *   signature: {
         *     field: "signature filed...",
         *     scalar: "scalar..."
         *   },
         * })
         */
        verifyMessage(args: VerifyMessageArgs): Promise<boolean>;

        /**
         * Used for signature fields.
         * @example
         * try {
         *   const signFieldsResult = await window.mina.signFields({
         *     message: [1,2,3],// or ["1","2","3"]
         *   }).catch(err => err)
         *   console.log(signFieldsResult)
         * } catch (error) {
         *   console.log(error.message, error.code)
         * }
         */
        signFields(args: SignFieldsArguments): Promise<SignedFieldsData>;

        /**
         * Used for verify signature fields information.
         * @example
         * let fieldsVerifyResult:boolean = await window.mina.verifyMessage({
         *   publicKey: "B62...",
         *   signature: "signature result...",
         *   payload: "sign field..."
         * })
         */
        verifyFields(args: VerifyFieldsArguments): Promise<boolean>;

        /**
         * Sign and broadcast a payment transaction.
         * @example
         * try {
         *   const { hash } = await window.mina.sendLegacyPayment({
         *     amount: 1,
         *     fee: 0.1,
         *     to: "B62qm3V7qSQ97Stgo2MXv4Apof2cVezZyP1VYJ8DfrVNy9yfqKZxLQf",
         *   })
         *   console.log(hash)
         * } catch (error) {
         *   console.log(error.message, error.code)
         * }
         */
        sendLegacyPayment(args: SendPaymentArgs): Promise<{ hash: string }>;

        /**
         * Sign and broadcast a skake delegation transaction.
         * @example
         * try {
         *   const { hash } = await window.mina.sendLegacyStakeDelegation({
         *     fee: 0.1,
         *     to: "B62qq3TQ8AP7MFYPVtMx5tZGF3kWLJukfwG1A1RGvaBW1jfTPTkDBW6",
         *   })
         *   console.log(hash)
         * } catch (error) {
         *   console.log(error.message, error.code)
         * }
         */
        sendLegacyStakeDelegation(args: SendStakeDelegationArgs): Promise<{ hash: string }>;

        /**
         * accountsChanged will be triggered when user switch connected account in Auro Wallet.
         * @example
         * window.mina.on('accountsChanged', handler: (accounts: string[]) => {
         *   console.log('connected accounts', accounts)
         * });
         *
         */
        on(event: 'accountsChanged', handler: (accounts: string[]) => void): void;

        /**
         * chainChanged will be triggered when user switch chainType in Auro Wallet.
         * @example
         * window.mina.on('chainChanged', handler: (chainType: string[]) => {
         *   console.log('current chain', chainType)
         * });
         */
        on(event: 'chainChanged', handler: (chainType: string) => void): void;
    };
}

export interface SendTransactionArgs {
    transaction: any;
    feePayer?: {
        fee?: number;
        memo?: string;
    };
}

export interface SignMessageArgs {
    message: string;
}

export interface SignedData {
    publicKey: string;
    data: string;
    signature: {
        field: string;
        scalar: string;
    };
}

export interface VerifyMessageArgs {
    publicKey: string;
    payload: string;
    signature: {
        field: string;
        scalar: string;
    };
}

export type SignFieldsArguments = {
    message: (string | number)[];
};

export type SignedFieldsData = {
    data: (string | number)[];
    signature: string;
};

export interface VerifyFieldsArguments {
    publicKey: string;
    payload: (string | number)[];
    signature: string;
}

export interface SendPaymentArgs {
    to: string;
    amount: number;
    fee?: number;
    memo?: string;
}

export interface SendStakeDelegationArgs {
    to: string;
    fee?: number;
    memo?: string;
}
